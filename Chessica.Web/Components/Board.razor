@using Chessica.Core
@using Chessica.Pgn
@using Chessica.Uci
@using Optional
@using System.Collections.Immutable
@using System.Text

<div class="panel-wrapper">
    <div class="menu-bar-panel">
        <button class="menu-button" onclick="@NewGame_White_OnClick">New Game (White)</button>
    </div>
    <div class="menu-bar-panel">
        <button class="menu-button" onclick="@NewGame_Black_OnClick">New Game (Black)</button>
    </div>
    <div class="menu-bar-panel">
        <button class="menu-button @(CanUndo ? "" : "menu-button-disabled")" onclick="@Undo_OnClick">Undo Last Full Move</button>
    </div>
    <div class="board-panel">
        <div class="board">
            @foreach (var coord in AllCoords)
            {
                <Square Board="_boardState"
                        Coord="coord"
                        BoardInverted="BoardInverted"
                        IsSelected="IsSelected(coord)"
                        IsPotentialMove="IsPotentialMove(coord)"
                        IsPotentialCapture="IsPotentialCapture(coord)"
                        OnClick="Square_OnClick"
                        OnDragStart="Square_OnDragStart"
                        OnDrop="Square_OnDrop"/>
            }
        </div>
    </div>
    <div class="status-bar-panel">
        <span style="font-weight: bold; font-size: 14pt">Status</span>
        <p>@(StatusMessage)</p>
    </div>
    <div class="move-history-panel">
        <span style="font-weight: bold; font-size: 14pt">Move History</span>
        <div>
            <pre>@(PgnMoveHistory)</pre>
        </div>
    </div>
</div>

@code {

    [CascadingParameter] public IModalService Modal { get; set; } = default!;

    public Side UserSide { get; set; }

    public Side EngineSide => UserSide == Side.White ? Side.Black : Side.White;

    BoardState _boardState = BoardState.StartingPosition;
    Option<Coord> _selectedSquare;
    List<Move> _legalMoves = new();
    Stack<PgnMove> _pgnMoves = new();
    private PgnGameResult _pgnResult = PgnGameResult.Other;

    public async Task NewGame_White_OnClick()
    {
        await NewGame(Side.White);
    }

    public async Task NewGame_Black_OnClick()
    {
        await NewGame(Side.Black);
    }

    public bool CanUndo = false;
    
    public string StatusMessage { get; set; } = string.Empty;

    public void Undo_OnClick()
    {
        if (!CanUndo) return;
        _boardState.TryPop();
        var lastMove = _pgnMoves.Pop();
        if (lastMove.Side == EngineSide)
        {
            // also pop user's last move
            _boardState.TryPop();
            _pgnMoves.Pop();
        }
        CanUndo = _pgnMoves.Count > (UserSide == Side.White ? 1 : 2);
        _pgnResult = PgnGameResult.Other;
        _legalMoves = _boardState.GetLegalMoves().ToList();
        if (_pgnMoves.Any())
        {
            var lastEngineMove = _pgnMoves.Last();
            StatusMessage = $"Last engine move: {lastEngineMove.Spec}";
        }
        else
        {
            StatusMessage = string.Empty;
        }
    }

    public async Task NewGame(Side userSide)
    {
        UserSide = userSide;
        _boardState = BoardState.StartingPosition;
        _selectedSquare = Option.None<Coord>();
        _legalMoves = _boardState.GetLegalMoves().ToList();
        _pgnMoves = new Stack<PgnMove>();
        _pgnResult = PgnGameResult.Other;
        StatusMessage = string.Empty;
        if (!IsUsersMove)
        {
            await MakeEngineMove();
        }
    }

    public async Task MakeEngineMove()
    {
        if (IsUsersMove) return;
        var (inCheck, numLegalMoves) = _boardState.GetGameState();
        if (numLegalMoves == 0)
        {
            _pgnResult = inCheck
                ? UserSide == Side.White ? PgnGameResult.WhiteWin : PgnGameResult.BlackWin
                : PgnGameResult.Draw;
            StatusMessage = inCheck
                ? "Bloody hell mate, looks like you've got me!"
                : "Managed to snatch a draw off you!";
            return;
        }
        CanUndo = false;
        StatusMessage = "Thinking...";
        var engineMove = await Task.Run(() => new MiniMaxMoveGenerator(4).GetBestMove(_boardState));
        var pgnSpec = engineMove.ToPgnSpec(_boardState);
        _boardState.Push(engineMove);
        (inCheck, numLegalMoves) = _boardState.GetGameState();
        if (inCheck)
        {
            pgnSpec += numLegalMoves == 0 ? "#" : "+";
        }
        _pgnMoves.Push(new PgnMove(EngineSide, pgnSpec));
        CanUndo = _pgnMoves.Count > (UserSide == Side.White ? 1 : 2);
        if (inCheck)
        {
            if (numLegalMoves == 0)
            {
                _pgnResult = EngineSide == Side.White ? PgnGameResult.WhiteWin : PgnGameResult.BlackWin;
                StatusMessage = "Human scum, you are no match for Chessica";
                return;
            }
        }
        else if (numLegalMoves == 0)
        {
            _pgnResult = PgnGameResult.Draw;
            StatusMessage = "Looks a bit stale to me, mate";
            return;
        }
        _legalMoves = _boardState.GetLegalMoves().ToList();
        StatusMessage = $"Last engine move: {pgnSpec}";
    }

    public bool BoardInverted => UserSide == Side.Black;

    public bool IsUsersMove => _boardState.SideToMove == UserSide;

    public IEnumerable<Coord> AllCoords => BoardInverted
        ? Coord.All.OrderBy(c => c.Rank).ThenByDescending(c => c.File)
        : Coord.All.OrderByDescending(c => c.Rank).ThenBy(c => c.File);

    public string PgnMoveHistory
    {
        get
        {
            using var memoryStream = new MemoryStream();
            new PgnGame(ImmutableDictionary<string, string>.Empty, _pgnMoves.Reverse().ToImmutableArray(), _pgnResult).WriteToStream(memoryStream);
            return Encoding.UTF8.GetString(memoryStream.ToArray());
        }
    }

    private bool IsSelected(Coord coord)
    {
        return _selectedSquare.Match(s => s == coord, () => false);
    }

    private bool IsPotentialMove(Coord coord)
    {
        return _selectedSquare.Match(
            s => _legalMoves.Any(m => m.From == s && m.To == coord && !m.IsCapture),
            () => false);
    }

    private bool IsPotentialCapture(Coord coord)
    {
        return _selectedSquare.Match(
            s => _legalMoves.Any(m => m.From == s && m.To == coord && m.IsCapture),
            () => false);
    }

    private async Task Square_OnClick(Coord coord)
    {
        if (!IsUsersMove) return;
        if (_selectedSquare.HasValue)
        {
            await _selectedSquare.MatchSomeAsync(
                async currentlySelected =>
                {
                    if (currentlySelected == coord)
                    {
                        _selectedSquare = Option.None<Coord>();
                    }
                    else
                    {
                        await TryMoveAsync(currentlySelected, coord);
                    }
                });
        }
        else
        {
            _boardState.GetPiece(UserSide, coord).MatchSome(_ => _selectedSquare = Option.Some(coord));
        }

        if (!IsUsersMove)
        {
            await MakeEngineMove();
        }
    }

    private void Square_OnDragStart(Coord coord)
    {
        if (!IsUsersMove) return;
        _boardState.GetPiece(UserSide, coord).MatchSome(_ => _selectedSquare = Option.Some(coord));
    }

    private async Task Square_OnDrop(Coord coord)
    {
        if (!IsUsersMove) return;
        await _selectedSquare.MatchSomeAsync(
            async currentlySelected => await TryMoveAsync(currentlySelected, coord));
        if (!IsUsersMove)
        {
            await MakeEngineMove();
        }
    }

    private async Task TryMoveAsync(Coord from, Coord to)
    {
        var potentialMoves = _legalMoves.Where(m => m.From == from && m.To == to).ToList();
        switch (potentialMoves.Count)
        {
            case 1:
            {
                var move = potentialMoves.Single();
                var moveSpec = move.ToPgnSpec(_boardState);
                _boardState.Push(move);

                var (inCheck, numLegalMoves) = _boardState.GetGameState();
                if (inCheck)
                {
                    moveSpec += numLegalMoves == 0 ? "#" : "+";
                }
                _pgnMoves.Push(new PgnMove(UserSide, moveSpec));

                break;
            }
            case > 1:
            {
                var promotionChoice = Modal.Show<PromotionChoice>(
                    string.Empty, new ModalParameters().Add("UserSide", UserSide));

                var result = await promotionChoice.Result;

                if (!result.Cancelled && result.Data is Piece piece)
                {
                    var move = potentialMoves.OfType<PromotionMove>().Single(m => m.Promotion == piece);
                    var moveSpec = move.ToPgnSpec(_boardState);
                    _boardState.Push(move);

                    var (inCheck, numLegalMoves) = _boardState.GetGameState();
                    if (inCheck)
                    {
                        moveSpec += numLegalMoves == 0 ? "#" : "+";
                    }
                    _pgnMoves.Push(new PgnMove(UserSide, moveSpec));
                }
                break;
            }
        }
        _selectedSquare = Option.None<Coord>();
    }

    protected override async Task OnInitializedAsync()
    {
        await NewGame(Side.White);
        LoadGame();
    }

    private void LoadGame()
    {
        const string pgn = @"1. e4 e6
2. Nc3 d6
3. d4 e5
4. dxe5 dxe5
5. Bb5+ Nd7
6. Nf3 Bd6
7. O-O Nf6
8. Bg5 O-O
9. Nb1 h6
10. Bxd7 Bxd7
11. Bxf6 Qxf6
12. Qd2 Bb5
13. c4 Bxc4
14. Rc1 b5
15. Qd1 Rfd8
16. a3 Bb4
17. Qc2 Ba5
18. b3 Bd3
19. Qc5 Bxe4
20. Qxb5 Bxf3
21. g3 Qf5
22. Qa6 Qh3
23. Qf1 Qxf1+
24. Rxf1 Rab8
25. b4 Bb6
26. Re1 Bd4
27. Ra2 c5
28. Rd2 c4
29. Kf1 c3
30. Rc2 Bg4
31. Nxc3 Bxc3
32. Rxc3 Rd2
33. Rxe5 Rbd8
34. Kg1 Bh3
35. Rce3 Rd1+
36. Re1 Rxe1+
37. Rxe1 Rd3
38. Re8+ Kh7
39. Re1 Rxa3
40. Kh1 Rb3
41. Ra1 Rxb4
42. Kg1 a5
43. Kh1 a4
44. Kg1 a3
45. Kh1 a2
46. Rc1 
";

        _boardState = BoardState.StartingPosition;
        var pgnGame = PgnGame.Parse(pgn);
        foreach (var pgnMove in pgnGame.Moves)
        {
            _boardState.Push(_boardState.ToMove(pgnMove.Spec));
            _pgnMoves.Push(pgnMove);
        }
        _legalMoves = _boardState.GetLegalMoves().ToList();
        UserSide = Side.Black;
    }
}